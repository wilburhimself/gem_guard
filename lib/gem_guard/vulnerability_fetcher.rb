require "net/http"
require "json"
require "uri"

module GemGuard
  class VulnerabilityFetcher
    OSV_API_URL = "https://api.osv.dev/v1/query"
    RUBY_ADVISORY_DB_URL = "https://raw.githubusercontent.com/rubysec/ruby-advisory-db/master/gems"
    GHSA_API_URL = "https://api.github.com/advisories"
    NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    CU_ADVISORY_DB_URL = "https://github.com/curesec/curesec-advisory-db"

    def fetch_for(dependencies)
      vulnerabilities = []

      dependencies.each do |dependency|
        vulnerabilities.concat(fetch_osv_vulnerabilities(dependency))
        vulnerabilities.concat(fetch_ruby_advisory_vulnerabilities(dependency))
        vulnerabilities.concat(fetch_ghsa_vulnerabilities(dependency))
        vulnerabilities.concat(fetch_nvd_vulnerabilities(dependency))
        vulnerabilities.concat(fetch_cu_advisory_vulnerabilities(dependency))
      end

      # Deduplicate vulnerabilities by ID and gem name, merging affected/fixed versions
      deduplicated = {}
      vulnerabilities.each do |vuln|
        key = [vuln.id, vuln.gem_name]
        if deduplicated[key]
          # Merge affected and fixed versions from duplicate entries
          existing = deduplicated[key]
          merged_affected = (existing.affected_versions + vuln.affected_versions).uniq
          merged_fixed = (existing.fixed_versions + vuln.fixed_versions).uniq

          deduplicated[key] = Vulnerability.new(
            id: existing.id,
            gem_name: existing.gem_name,
            affected_versions: merged_affected,
            fixed_versions: merged_fixed,
            severity: existing.severity,
            summary: existing.summary,
            details: existing.details
          )
        else
          deduplicated[key] = vuln
        end
      end

      deduplicated.values
    end

    private

    def fetch_osv_vulnerabilities(dependency)
      query = {
        package: {
          name: dependency.name,
          ecosystem: "RubyGems"
        },
        version: dependency.version
      }

      response = make_http_request(OSV_API_URL, query.to_json)
      return [] unless response

      data = JSON.parse(response)
      return [] unless data["vulns"]

      data["vulns"].map do |vuln_data|
        Vulnerability.new(
          id: vuln_data["id"],
          gem_name: dependency.name,
          affected_versions: extract_affected_versions(vuln_data),
          fixed_versions: extract_fixed_versions(vuln_data),
          severity: extract_severity(vuln_data),
          summary: vuln_data["summary"],
          details: vuln_data["details"]
        )
      end
    rescue JSON::ParserError
      []
    end

    def fetch_ruby_advisory_vulnerabilities(dependency)
      # For now, return empty array - will implement Ruby Advisory DB fetching later
      []
    end

    def fetch_ghsa_vulnerabilities(dependency)
      # GitHub Security Advisory fetching implementation
      # Note: This requires GitHub API authentication for full access
      url = "#{GHSA_API_URL}?ecosystem=rubygems&package=#{dependency.name}"
      response = make_http_request(url)
      return [] unless response

      data = JSON.parse(response)
      return [] unless data.is_a?(Array)

      data.map do |vuln_data|
        Vulnerability.new(
          id: vuln_data["ghsa_id"] || vuln_data["id"],
          gem_name: dependency.name,
          affected_versions: extract_ghsa_affected_versions(vuln_data),
          fixed_versions: extract_ghsa_fixed_versions(vuln_data),
          severity: extract_ghsa_severity(vuln_data),
          summary: vuln_data["summary"] || "",
          details: vuln_data["description"] || ""
        )
      end
    rescue JSON::ParserError
      []
    end

    def fetch_nvd_vulnerabilities(dependency)
      # NVD (National Vulnerability Database) fetching implementation
      # Search for vulnerabilities related to the gem name
      url = "#{NVD_API_URL}?keywordSearch=#{dependency.name}"
      response = make_http_request(url)
      return [] unless response

      data = JSON.parse(response)
      return [] unless data["vulnerabilities"]

      data["vulnerabilities"].map do |vuln_data|
        # Check if this vulnerability actually affects the gem
        cpe_match = vuln_data.dig("cve", "configurations", 0, "nodes", 0, "cpeMatch") || []
        next unless cpe_match.any? { |match| match["criteria"]&.include?(dependency.name) }

        Vulnerability.new(
          id: vuln_data.dig("cve", "id") || "NVD-#{Time.now.to_i}",
          gem_name: dependency.name,
          affected_versions: extract_nvd_affected_versions(vuln_data),
          fixed_versions: extract_nvd_fixed_versions(vuln_data),
          severity: extract_nvd_severity(vuln_data),
          summary: vuln_data.dig("cve", "descriptions", 0, "value") || "",
          details: vuln_data.dig("cve", "descriptions", 0, "value") || ""
        )
      end.compact
    rescue JSON::ParserError
      []
    end

    def fetch_cu_advisory_vulnerabilities(dependency)
      # CU (Curesec) Advisory DB fetching implementation
      # This is a placeholder implementation - would need to be expanded
      # based on the actual structure of the Curesec advisory database
      []
    end

    def make_http_request(url, body = nil)
      uri = URI(url)
      http = Net::HTTP.new(uri.host, uri.port)
      http.use_ssl = true if uri.scheme == "https"

      request = if body
        req = Net::HTTP::Post.new(uri)
        req["Content-Type"] = "application/json"
        req.body = body
        req
      else
        Net::HTTP::Get.new(uri)
      end

      response = http.request(request)
      response.body if response.code == "200"
    rescue
      nil
    end

    def extract_affected_versions(vuln_data)
      return [] unless vuln_data["affected"]

      vuln_data["affected"]
        .select { |affected| affected.dig("package", "ecosystem") == "RubyGems" }
        .flat_map { |affected| affected["ranges"] || [] }
        .flat_map { |range| range["events"] || [] }
        .map { |event| event["introduced"] || event["fixed"] }
        .compact
    end

    def extract_fixed_versions(vuln_data)
      return [] unless vuln_data["affected"]

      vuln_data["affected"]
        .select { |affected| affected.dig("package", "ecosystem") == "RubyGems" }
        .flat_map { |affected| affected["ranges"] || [] }
        .flat_map { |range| range["events"] || [] }
        .filter_map { |event| event["fixed"] }
    end

    def extract_severity(vuln_data)
      return "UNKNOWN" unless vuln_data["severity"]

      vuln_data["severity"].first&.dig("score") || "UNKNOWN"
    end

    # GHSA-specific extraction methods
    def extract_ghsa_affected_versions(vuln_data)
      # Extract affected versions from GHSA data
      vuln_data.dig("vulnerabilities", 0, "firstPatchedVersion", "identifier") ? [vuln_data.dig("vulnerabilities", 0, "vulnerableVersionRange")] : []
    rescue
      []
    end

    def extract_ghsa_fixed_versions(vuln_data)
      # Extract fixed versions from GHSA data
      fixed = vuln_data.dig("vulnerabilities", 0, "firstPatchedVersion", "identifier")
      fixed ? [fixed] : []
    rescue
      []
    end

    def extract_ghsa_severity(vuln_data)
      # Extract severity from GHSA data
      vuln_data["severity"] || "UNKNOWN"
    end

    # NVD-specific extraction methods
    def extract_nvd_affected_versions(vuln_data)
      # Extract affected versions from NVD data
      []
    end

    def extract_nvd_fixed_versions(vuln_data)
      # Extract fixed versions from NVD data
      []
    end

    def extract_nvd_severity(vuln_data)
      # Extract severity from NVD data
      metrics = vuln_data.dig("cve", "metrics", "cvssMetricV31", 0) || vuln_data.dig("cve", "metrics", "cvssMetricV2", 0)
      metrics&.dig("cvssData", "baseScore")&.to_s || "UNKNOWN"
    end
  end

  class Vulnerability
    attr_reader :id, :gem_name, :affected_versions, :fixed_versions, :severity, :summary, :details

    def initialize(id:, gem_name:, affected_versions: [], fixed_versions: [], severity: "UNKNOWN", summary: "", details: "")
      @id = id
      @gem_name = gem_name
      @affected_versions = affected_versions
      @fixed_versions = fixed_versions
      @severity = severity
      @summary = summary
      @details = details
    end

    def ==(other)
      other.is_a?(Vulnerability) && id == other.id
    end
  end
end
